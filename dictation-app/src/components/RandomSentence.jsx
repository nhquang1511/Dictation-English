import { useState, useEffect } from "react";
import "./RandomSentenceApp.css";

const levels = ["A1", "A2", "B1", "B2", "C1", "C2"];

// Danh s√°ch ch·ªß ƒë·ªÅ ng·ªØ ph√°p ƒë√£ ƒë∆∞·ª£c m·ªü r·ªông v√† chi ti·∫øt h√≥a
const topics = [
    // 1. Th√¨ (Tenses)
    "Hi·ªán t·∫°i ƒë∆°n",
    "Hi·ªán t·∫°i ti·∫øp di·ªÖn",
    "Hi·ªán t·∫°i ho√†n th√†nh",
    "Hi·ªán t·∫°i ho√†n th√†nh ti·∫øp di·ªÖn",
    "Qu√° kh·ª© ƒë∆°n",
    "Qu√° kh·ª© ti·∫øp di·ªÖn",
    "Qu√° kh·ª© ho√†n th√†nh",
    "Qu√° kh·ª© ho√†n th√†nh ti·∫øp di·ªÖn",
    "T∆∞∆°ng lai ƒë∆°n",
    "T∆∞∆°ng lai ti·∫øp di·ªÖn",
    "T∆∞∆°ng lai ho√†n th√†nh",
    "T∆∞∆°ng lai ho√†n th√†nh ti·∫øp di·ªÖn",
    "Th√¨ t∆∞∆°ng lai g·∫ßn (be going to)",
    "Th√¨ hi·ªán t·∫°i ƒë∆°n di·ªÖn t·∫£ t∆∞∆°ng lai",

    // 2. Lo·∫°i c√¢u & C·∫•u tr√∫c ƒë·∫∑c bi·ªát (Sentence Types & Special Structures)
    "C√¢u b·ªã ƒë·ªông",
    "C√¢u ƒëi·ªÅu ki·ªán lo·∫°i 1",
    "C√¢u ƒëi·ªÅu ki·ªán lo·∫°i 2",
    "C√¢u ƒëi·ªÅu ki·ªán lo·∫°i 3",
    "C√¢u ƒëi·ªÅu ki·ªán h·ªón h·ª£p",
    "C√¢u gi√°n ti·∫øp",
    "M·ªánh ƒë·ªÅ quan h·ªá",
    "C√¢u ƒë·∫£o ng·ªØ",
    "C√¢u gi·∫£ ƒë·ªãnh (Subjunctive)",
    "C√¢u c·∫£m th√°n",
    "C√¢u m·ªánh l·ªánh",

    // 3. C√°c lo·∫°i t·ª´ & Ch·ª©c nƒÉng (Parts of Speech & Functions)
    "Danh t·ª´",
    "ƒê·∫°i t·ª´",
    "T√≠nh t·ª´",
    "Tr·∫°ng t·ª´",
    "Gi·ªõi t·ª´", // C·∫ßn l∆∞u √Ω kh√≥ t·∫°o g·ª£i √Ω c·∫•u tr√∫c t·ªïng qu√°t
    "Li√™n t·ª´",
    "M·∫°o t·ª´ (a/an/the)",
    "ƒê·ªông t·ª´ khuy·∫øt thi·∫øu (Modal verbs)",
    "C·ª•m ƒë·ªông t·ª´ (Phrasal verbs)",

    // 4. C√°c ƒëi·ªÉm ng·ªØ ph√°p kh√°c (Other Grammar Points)
    "S·ª± h√≤a h·ª£p ch·ªß v·ªã (Subject-Verb Agreement)",
    "Gerund v√† Infinitive (V-ing v√† To-V)",
    "So s√°nh (Comparisons)",
    "C√¢u h·ªèi ƒëu√¥i (Tag questions)",
    "C·∫•u tr√∫c WISH",
    "C·∫•u tr√∫c IT IS + ADJ + TO-V",
    "C·∫•u tr√∫c ENOUGH/TOO",
    "C√¢u gh√©p (Compound Sentence)"
];

const types = [
    "kh·∫≥ng ƒë·ªãnh",
    "ph·ªß ƒë·ªãnh",
    "c√¢u h·ªèi yes/no",
    "c√¢u h·ªèi wh-",
    "c√¢u h·ªèi ƒëu√¥i", // ƒê·∫∑c bi·ªát h∆°n, c√≥ th·ªÉ kh√¥ng √°p d·ª•ng cho t·∫•t c·∫£ topic
    "m·ªánh l·ªánh", // ƒê·∫∑c bi·ªát h∆°n
    "c√¢u c·∫£m th√°n" // ƒê·∫∑c bi·ªát h∆°n
];


export default function RandomSentenceApp() {
    const [level, setLevel] = useState("A2");
    const [topic, setTopic] = useState("Hi·ªán t·∫°i ƒë∆°n"); // C·∫≠p nh·∫≠t topic m·∫∑c ƒë·ªãnh
    const [type, setType] = useState("kh·∫≥ng ƒë·ªãnh");

    const [sentence, setSentence] = useState(null);
    const [structureHint, setStructureHint] = useState("");
    const [userInput, setUserInput] = useState("");
    const [result, setResult] = useState(null);
    const [loading, setLoading] = useState(false);

    const fetchSentence = async () => {
        setLoading(true); // B·∫Øt ƒë·∫ßu loading
        try {
            // ƒê·∫£m b·∫£o topic v√† type ƒë∆∞·ª£c truy·ªÅn ƒë√∫ng c√°ch cho backend
            const res = await fetch(
                `http://localhost:5000/random-sentence-gemini?level=${level}&topic=${encodeURIComponent(topic)}&type=${encodeURIComponent(type)}`
            );
            if (!res.ok) {
                throw new Error(`HTTP error! status: ${res.status}`);
            }
            const data = await res.json();
            setSentence(data);
            setUserInput("");
            setResult(null);

            // T·∫°o g·ª£i √Ω c·∫•u tr√∫c d·ª±a tr√™n topic v√† type ƒë√£ ch·ªçn
            const structure = getStructureHint(topic, type);
            setStructureHint(structure);
        } catch (error) {
            console.error("Error fetching sentence:", error);
            setSentence({ vi: "Kh√¥ng th·ªÉ t·∫£i c√¢u. Vui l√≤ng th·ª≠ l·∫°i.", en: "" });
            setStructureHint("");
            setResult(null);
        } finally {
            setLoading(false); // K·∫øt th√∫c loading
        }
    };

    // `useEffect` n√†y s·∫Ω ch·∫°y m·ªói khi `level`, `topic`, `type` thay ƒë·ªïi
    useEffect(() => {
        fetchSentence();
    }, [level, topic, type]);

    const handleCheck = () => {
        setResult({
            corrected: sentence.en,
            is_correct: userInput.trim().toLowerCase() === sentence.en.trim().toLowerCase()
        });
    };


    return (
        <div className="random-sentence-app">
            <h2>Luy·ªán Vi·∫øt C√¢u Ti·∫øng Anh Theo Ng·ªØ Ph√°p</h2>

            <div className="controls">
                <select value={level} onChange={(e) => setLevel(e.target.value)}>
                    {levels.map((l) => <option key={l}>{l}</option>)}
                </select>
                <select value={topic} onChange={(e) => setTopic(e.target.value)}>
                    {topics.map((t) => (
                        <option key={t} value={t}>
                            {t}
                        </option>
                    ))}
                </select>
                {/* Ch·ªâ hi·ªÉn th·ªã selector type n·∫øu topic kh√¥ng ph·∫£i l√† "c√¢u h·ªèi ƒëu√¥i" ho·∫∑c "c√¢u m·ªánh l·ªánh"
                    v√¨ ch√∫ng ƒë√£ ng·∫ßm ƒë·ªãnh lo·∫°i c√¢u */}
                {!(topic === "C√¢u h·ªèi ƒëu√¥i" || topic === "C√¢u m·ªánh l·ªánh" || topic === "C√¢u c·∫£m th√°n") && (
                    <select value={type} onChange={(e) => setType(e.target.value)}>
                        {types.map((t) => <option key={t}>{t}</option>)}
                    </select>
                )}
                <button onClick={fetchSentence} disabled={loading}>
                    {loading ? "ƒêang t·∫£i..." : "üîÅ C√¢u m·ªõi"}
                </button>
            </div>

            {sentence && (
                <div className="exercise">
                    <p><strong>C√¢u ti·∫øng Vi·ªát:</strong> {sentence.vi}</p>
                    {structureHint && (
                        <div className="structure-hint">
                            <p>üìò G·ª£i √Ω c·∫•u tr√∫c: <code>{structureHint}</code></p>
                            {/* B·∫°n c√≥ th·ªÉ th√™m tooltip ho·∫∑c popup hi·ªÉn th·ªã gi·∫£i th√≠ch chi ti·∫øt h∆°n khi click v√†o ƒë√¢y */}
                        </div>
                    )}
                    <textarea
                        rows={3}
                        value={userInput}
                        onChange={(e) => setUserInput(e.target.value)}
                        onKeyDown={(e) => {
                            if (e.key === "Enter" && !e.shiftKey) {
                                e.preventDefault(); // NgƒÉn xu·ªëng d√≤ng
                                handleCheck();      // G·ªçi h√†m ki·ªÉm tra
                            }
                        }}
                        placeholder="B·∫°n h√£y vi·∫øt c√¢u ti·∫øng Anh t·∫°i ƒë√¢y..."
                        disabled={loading}
                    />

                    <div style={{ display: "flex", gap: "10px" }}>
                        <button onClick={handleCheck} disabled={loading || !userInput.trim()}>
                            {loading ? "ƒêang ki·ªÉm tra..." : "Ki·ªÉm tra"}
                        </button>
                        <button onClick={fetchSentence} disabled={loading}>
                            {loading ? "ƒêang t·∫£i..." : "‚û°Ô∏è Next"}
                        </button>
                    </div>

                </div>
            )}

            {result && (
                <div className="feedback">
                    <p><strong>‚úÖ C√¢u ƒë√∫ng:</strong> {sentence.en}</p>
                </div>
            )}
        </div>
    );
}

// H√†m g·ª£i √Ω c·∫•u tr√∫c d·ª±a tr√™n topic V√Ä lo·∫°i c√¢u
function getStructureHint(topic, type = "kh·∫≥ng ƒë·ªãnh") {
    const hints = {
        // 1. Th√¨ (Tenses)
        "Hi·ªán t·∫°i ƒë∆°n": {
            "kh·∫≥ng ƒë·ªãnh": "S + V(s/es)",
            "ph·ªß ƒë·ªãnh": "S + do/does + not + V(nguy√™n m·∫´u)",
            "c√¢u h·ªèi yes/no": "Do/Does + S + V(nguy√™n m·∫´u)?",
            "c√¢u h·ªèi wh-": "Wh-word + do/does + S + V(nguy√™n m·∫´u)?",
        },
        "Hi·ªán t·∫°i ti·∫øp di·ªÖn": {
            "kh·∫≥ng ƒë·ªãnh": "S + am/is/are + V-ing",
            "ph·ªß ƒë·ªãnh": "S + am/is/are + not + V-ing",
            "c√¢u h·ªèi yes/no": "Am/Is/Are + S + V-ing?",
            "c√¢u h·ªèi wh-": "Wh-word + am/is/are + S + V-ing?",
        },
        "Hi·ªán t·∫°i ho√†n th√†nh": {
            "kh·∫≥ng ƒë·ªãnh": "S + have/has + V3/ed",
            "ph·ªß ƒë·ªãnh": "S + have/has + not + V3/ed",
            "c√¢u h·ªèi yes/no": "Have/Has + S + V3/ed?",
            "c√¢u h·ªèi wh-": "Wh-word + have/has + S + V3/ed?",
        },
        "Hi·ªán t·∫°i ho√†n th√†nh ti·∫øp di·ªÖn": {
            "kh·∫≥ng ƒë·ªãnh": "S + have/has + been + V-ing",
            "ph·ªß ƒë·ªãnh": "S + have/has + not + been + V-ing",
            "c√¢u h·ªèi yes/no": "Have/Has + S + been + V-ing?",
            "c√¢u h·ªèi wh-": "Wh-word + have/has + S + been + V-ing?",
        },
        "Qu√° kh·ª© ƒë∆°n": {
            "kh·∫≥ng ƒë·ªãnh": "S + V2/ed",
            "ph·ªß ƒë·ªãnh": "S + did + not + V(nguy√™n m·∫´u)",
            "c√¢u h·ªèi yes/no": "Did + S + V(nguy√™n m·∫´u)?",
            "c√¢u h·ªèi wh-": "Wh-word + did + S + V(nguy√™n m·∫´u)?",
        },
        "Qu√° kh·ª© ti·∫øp di·ªÖn": {
            "kh·∫≥ng ƒë·ªãnh": "S + was/were + V-ing",
            "ph·ªß ƒë·ªãnh": "S + was/were + not + V-ing",
            "c√¢u h·ªèi yes/no": "Was/Were + S + V-ing?",
            "c√¢u h·ªèi wh-": "Wh-word + was/were + S + V-ing?",
        },
        "Qu√° kh·ª© ho√†n th√†nh": {
            "kh·∫≥ng ƒë·ªãnh": "S + had + V3/ed",
            "ph·ªß ƒë·ªãnh": "S + had + not + V3/ed",
            "c√¢u h·ªèi yes/no": "Had + S + V3/ed?",
            "c√¢u h·ªèi wh-": "Wh-word + had + S + V3/ed?",
        },
        "Qu√° kh·ª© ho√†n th√†nh ti·∫øp di·ªÖn": {
            "kh·∫≥ng ƒë·ªãnh": "S + had + been + V-ing",
            "ph·ªß ƒë·ªãnh": "S + had + not + been + V-ing",
            "c√¢u h·ªèi yes/no": "Had + S + been + V-ing?",
            "c√¢u h·ªèi wh-": "Wh-word + had + S + been + V-ing?",
        },
        "T∆∞∆°ng lai ƒë∆°n": {
            "kh·∫≥ng ƒë·ªãnh": "S + will + V(nguy√™n m·∫´u)",
            "ph·ªß ƒë·ªãnh": "S + will + not + V(nguy√™n m·∫´u)",
            "c√¢u h·ªèi yes/no": "Will + S + V(nguy√™n m·∫´u)?",
            "c√¢u h·ªèi wh-": "Wh-word + will + S + V(nguy√™n m·∫´u)?",
        },
        "T∆∞∆°ng lai ti·∫øp di·ªÖn": {
            "kh·∫≥ng ƒë·ªãnh": "S + will + be + V-ing",
            "ph·ªß ƒë·ªãnh": "S + will + not + be + V-ing",
            "c√¢u h·ªèi yes/no": "Will + S + be + V-ing?",
            "c√¢u h·ªèi wh-": "Wh-word + will + S + be + V-ing?",
        },
        "T∆∞∆°ng lai ho√†n th√†nh": {
            "kh·∫≥ng ƒë·ªãnh": "S + will + have + V3/ed",
            "ph·ªß ƒë·ªãnh": "S + will + not + have + V3/ed",
            "c√¢u h·ªèi yes/no": "Will + S + have + V3/ed?",
            "c√¢u h·ªèi wh-": "Wh-word + will + S + have + V3/ed?",
        },
        "T∆∞∆°ng lai ho√†n th√†nh ti·∫øp di·ªÖn": {
            "kh·∫≥ng ƒë·ªãnh": "S + will + have + been + V-ing",
            "ph·ªß ƒë·ªãnh": "S + will + not + have + been + V-ing",
            "c√¢u h·ªèi yes/no": "Will + S + have + been + V-ing?",
            "c√¢u h·ªèi wh-": "Wh-word + will + S + have + been + V-ing?",
        },
        "Th√¨ t∆∞∆°ng lai g·∫ßn (be going to)": {
            "kh·∫≥ng ƒë·ªãnh": "S + am/is/are + going to + V(nguy√™n m·∫´u)",
            "ph·ªß ƒë·ªãnh": "S + am/is/are + not + going to + V(nguy√™n m·∫´u)",
            "c√¢u h·ªèi yes/no": "Am/Is/Are + S + going to + V(nguy√™n m·∫´u)?",
            "c√¢u h·ªèi wh-": "Wh-word + am/is/are + S + going to + V(nguy√™n m·∫´u)?",
        },
        "C√¢u gh√©p (Compound Sentence)": {
            "kh·∫≥ng ƒë·ªãnh": "MƒêƒêL 1, [FANBOYS](For, And, Nor, But, Or, Yet, So.) MƒêƒêL 2. Ho·∫∑c: MƒêƒêL 1; MƒêƒêL 2. Ho·∫∑c: MƒêƒêL 1; [adv li√™n k·∫øt], MƒêƒêL 2.",
            "ph·ªß ƒë·ªãnh": "T∆∞∆°ng t·ª± kh·∫≥ng ƒë·ªãnh, nh∆∞ng th√™m 'not' v√†o MƒêƒêL. V√≠ d·ª•: S + don't/doesn't + V.",
            "c√¢u h·ªèi yes/no": "Tr·ª£ ƒë·ªông t·ª´ + S + V..., [FANBOYS] S + V...?", // C√≥ th·ªÉ ph·ª©c t·∫°p h∆°n
            "c√¢u h·ªèi wh-": "Wh-word + tr·ª£ ƒë·ªông t·ª´ + S + V..., [FANBOYS] S + V...?", // C√≥ th·ªÉ ph·ª©c t·∫°p h∆°n
            // C√¢u h·ªèi ƒëu√¥i, m·ªánh l·ªánh, c·∫£m th√°n th∆∞·ªùng kh√¥ng √°p d·ª•ng cho to√†n b·ªô c√¢u gh√©p
        },
        "Th√¨ hi·ªán t·∫°i ƒë∆°n di·ªÖn t·∫£ t∆∞∆°ng lai": "S + V(s/es) (d√πng cho l·ªãch tr√¨nh, th·ªùi kh√≥a bi·ªÉu c·ªë ƒë·ªãnh)",

        // 2. Lo·∫°i c√¢u & C·∫•u tr√∫c ƒë·∫∑c bi·ªát
        "C√¢u b·ªã ƒë·ªông": "S + be (chia th√¨) + V3/ed + (by O)",
        "C√¢u ƒëi·ªÅu ki·ªán lo·∫°i 1": "If + S + V(hi·ªán t·∫°i ƒë∆°n), S + will/can/may + V(nguy√™n m·∫´u)",
        "C√¢u ƒëi·ªÅu ki·ªán lo·∫°i 2": "If + S + V(qu√° kh·ª© ƒë∆°n/were), S + would/could/might + V(nguy√™n m·∫´u)",
        "C√¢u ƒëi·ªÅu ki·ªán lo·∫°i 3": "If + S + had + V3/ed, S + would/could/might + have + V3/ed",
        "C√¢u ƒëi·ªÅu ki·ªán h·ªón h·ª£p": "K·∫øt h·ª£p If lo·∫°i 3 v√† M·ªánh ƒë·ªÅ ch√≠nh lo·∫°i 2, ho·∫∑c ng∆∞·ª£c l·∫°i.",
        "C√¢u gi√°n ti·∫øp": "S + said/told (that) + S + V (l√πi th√¨, ƒë·ªïi ƒë·∫°i t·ª´, tr·∫°ng t·ª´)",
        "M·ªánh ƒë·ªÅ quan h·ªá": "S + V... (Noun) + who/which/that/whose/where/when/why + S + V...",
        "C√¢u ƒë·∫£o ng·ªØ": "Tr·∫°ng t·ª´/c·ª•m t·ª´ ph·ªß ƒë·ªãnh (Never, Hardly, Not only...) + Tr·ª£ ƒë·ªông t·ª´ + S + V...",
        "C√¢u gi·∫£ ƒë·ªãnh (Subjunctive)": "It's important/necessary that S + V(nguy√™n m·∫´u) / S + suggest/demand that S + V(nguy√™n m·∫´u) / S + would rather + S + V(qu√° kh·ª© ƒë∆°n)",
        "C√¢u c·∫£m th√°n": "What + (a/an) + adj + Noun! ho·∫∑c How + adj/adv + S + V!",
        "C√¢u m·ªánh l·ªánh": "V(nguy√™n m·∫´u)... (kh·∫≥ng ƒë·ªãnh) / Don't + V(nguy√™n m·∫´u)... (ph·ªß ƒë·ªãnh)",

        // 3. C√°c lo·∫°i t·ª´ & Ch·ª©c nƒÉng
        "Danh t·ª´": "Danh t·ª´ (Noun): ch·ªâ ng∆∞·ªùi, v·∫≠t, s·ª± vi·ªác, √Ω t∆∞·ªüng. (S + V + N)",
        "ƒê·∫°i t·ª´": "ƒê·∫°i t·ª´ (Pronoun): thay th·∫ø danh t·ª´ (I, you, he, she, it, we, they; me, him, her; mine, yours...).",
        "T√≠nh t·ª´": "T√≠nh t·ª´ (Adjective): b·ªï nghƒ©a cho danh t·ª´ (adj + N) ho·∫∑c sau to be/linking verbs (S + be/linking verb + adj).",
        "Tr·∫°ng t·ª´": "Tr·∫°ng t·ª´ (Adverb): b·ªï nghƒ©a cho ƒë·ªông t·ª´, t√≠nh t·ª´, tr·∫°ng t·ª´ kh√°c (V + adv / adv + adj / adv + adv).",
        "Gi·ªõi t·ª´": "Gi·ªõi t·ª´ (Preposition): ch·ªâ v·ªã tr√≠, th·ªùi gian, c√°ch th·ª©c (in, on, at, with, by, for...).",
        "Li√™n t·ª´": "Li√™n t·ª´ (Conjunction): n·ªëi c√°c t·ª´, c·ª•m t·ª´, m·ªánh ƒë·ªÅ (and, but, or, so, because, although, if...).",
        "M·∫°o t·ª´ (a/an/the)": "a/an: d√πng tr∆∞·ªõc danh t·ª´ ƒë·∫øm ƒë∆∞·ª£c s·ªë √≠t ch∆∞a x√°c ƒë·ªãnh; the: d√πng khi danh t·ª´ ƒë√£ x√°c ƒë·ªãnh.",
        "ƒê·ªông t·ª´ khuy·∫øt thi·∫øu (Modal verbs)": "S + modal verb (can/could/may/might/must/should/will/would) + V(nguy√™n m·∫´u).",
        "C·ª•m ƒë·ªông t·ª´ (Phrasal verbs)": "ƒê·ªông t·ª´ + gi·ªõi t·ª´/tr·∫°ng t·ª´ (v√≠ d·ª•: look for, turn off, give up, take off).",

        // 4. C√°c ƒëi·ªÉm ng·ªØ ph√°p kh√°c
        "S·ª± h√≤a h·ª£p ch·ªß v·ªã (Subject-Verb Agreement)": "Ch·ªß ng·ªØ s·ªë √≠t -> ƒê·ªông t·ª´ s·ªë √≠t; Ch·ªß ng·ªØ s·ªë nhi·ªÅu -> ƒê·ªông t·ª´ s·ªë nhi·ªÅu.",
        "Gerund v√† Infinitive (V-ing v√† To-V)": "Gerund (V-ing): sau gi·ªõi t·ª´/m·ªôt s·ªë ƒë·ªông t·ª´; Infinitive (To-V): sau m·ªôt s·ªë ƒë·ªông t·ª´/ƒë·ªÉ ch·ªâ m·ª•c ƒë√≠ch.",
        "So s√°nh (Comparisons)": "So s√°nh b·∫±ng: as + adj/adv + as; So s√°nh h∆°n: adj-er/more adj + than; So s√°nh nh·∫•t: the + adj-est/most adj.",
        "C√¢u h·ªèi ƒëu√¥i (Tag questions)": "M·ªánh ƒë·ªÅ ch√≠nh (kh·∫≥ng ƒë·ªãnh), tr·ª£ ƒë·ªông t·ª´ + S (ph·ªß ƒë·ªãnh)? / M·ªánh ƒë·ªÅ ch√≠nh (ph·ªß ƒë·ªãnh), tr·ª£ ƒë·ªông t·ª´ + S (kh·∫≥ng ƒë·ªãnh)?",
        "C·∫•u tr√∫c WISH": "S + wish + S + V(l√πi th√¨) - (hi·ªán t·∫°i: qu√° kh·ª© ƒë∆°n, qu√° kh·ª©: qu√° kh·ª© ho√†n th√†nh).",
        "C·∫•u tr√∫c IT IS + ADJ + TO-V": "It is + t√≠nh t·ª´ + (for someone) + to + V(nguy√™n m·∫´u).",
        "C·∫•u tr√∫c ENOUGH/TOO": "adj/adv + enough + to-V / too + adj/adv + to-V.",
    };

    // L·∫•y g·ª£i √Ω c·∫•u tr√∫c
    let hint = hints[topic];

    // N·∫øu hint l√† m·ªôt ƒë·ªëi t∆∞·ª£ng (c√≥ c√°c lo·∫°i c√¢u con), truy c·∫≠p theo 'type'
    if (typeof hint === 'object' && hint !== null) {
        return hint[type] || hint["kh·∫≥ng ƒë·ªãnh"] || "Kh√¥ng c√≥ g·ª£i √Ω c·∫•u tr√∫c c·ª• th·ªÉ cho lo·∫°i c√¢u n√†y.";
    }
    // N·∫øu hint ch·ªâ l√† m·ªôt chu·ªói (kh√¥ng c√≥ c√°c lo·∫°i c√¢u con)
    return hint || "Kh√¥ng c√≥ g·ª£i √Ω c·∫•u tr√∫c c·ª• th·ªÉ.";
}